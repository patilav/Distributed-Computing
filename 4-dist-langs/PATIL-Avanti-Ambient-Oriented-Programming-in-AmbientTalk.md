
<meta charset=utf8>

# "Ambient-Oriented Programming in AmbientTalk", Dedecke, Cutsem, Mostinckx, D’Hondt, and De Meuter July 2006

Avanti Patil <patil.av@husky.neu.edu>

## Synopsis
This paper presents a new age field in distributed programming called Ambient intelligence (AmI). With emerging IoT business new problems which can’t be solved by conventional methods in programming. This paper talks about AmbientTalk – which is Ambient-Oriented Programming language (AmOP). Properties of mobile networks prominently include volatile connections and open network. Implementing languages based on Ambient-Oriented Programming paradigm help to deal with such problems. Research in this paper show that needs of mobile network are different from stationary n/w., AmbientTalk which is based on AmOP paradigm helps to solve these problems.  These concepts were implemented in an ambient peer-to-peer instant messaging app which was deployed on smart phones as part of this research.

## Summary

AmbientTalk features a classless double-layered object model. Ac- tors are visible in mobile networks and communicate with each other in a non- blocking way. Internally, they contain a graph of passive objects. Actors have four mailboxes which reify their communication traces and four mailboxes which are causally connected to the outside world to reflect the evolution of acquaintances in the ambient. These properties turn AmbientTalk into an AmOP language 

* Motivation for Ambient-Oriented Programming language(AmOP)

(1) Connection volatility, Ambient resources, Autonomy in hardware, Natural Concurrency – these are collectively described as hardware phenomena which is inherent to mobile networks. 

(2) Previous distributed languages based on actor model and futures only solve problems for mobile networks partially.

(3) Distributed Middlewares based on RPC, Data sharing, Publisher subscriber or Tuple based model do not fully solve problems of mobile networks like n/w volatility, ambient resources, autonomy and concurrency or well integrate with the object- oriented paradigm.

* Ambient-Oriented Programming 

(1)	Classless Object Models:  Even in the absence of wireless distribution, languages like Smalltalk and CLOS already illustrate that a serious reification of classes and their relation to objects results in extremely complex meta machinery. To avoid this complexity and proven classless object model of existing distributed programming languages such as Emerald, Obliq, dSelf and E moves AmOP to follow the same model. 

(2)	Non-Blocking Communication Primitives: 

This is a solution provided to avoid problems like autonomy. Non- blocking reception gives rise to event-driven applications, responsive to the stream of events generated by spontaneously interacting autonomous devices. Hence AmOP language needs a concurrency model without blocking communication primitives 

(3)	Reified Communication Traces:

Inconsistency is a huge issue in Non-blocking communication. AmOP paradigm has to provide programmers with an explicit representation (i.e. a reification) of the communication details which led to the inconsistent state. Reifying outgoing communication traces allow programmers to make a tradeoff between different delivery guarantees.

(4)	Ambient Acquaintance Management:

AmOp follows `Distributed naming`: where communicating parties do not need an explicit reference to each other beforehand. e.g. In Tuple space based middleware, a process can publish data in a tuple space, which can then be consulted by the other processes based on a pattern matching basis. AmOP language should allow an object to use distributed naming to spontaneously get acquainted with a previously unknown object based on an intentional description of that object rather than via a fixed URL. 

* The AmbientTalk Kernel 

AmbientTalk, is a language that was explicitly designed to satisfy its characteristics defined by Ambient-Oriented Programming. 

(1) A Double-layered Object Model:
AmbientTalk uses concurrent object model which is based on the model of ABCL/1.
This model features active objects which consist
    1)	perpetually running thread, 
    2)	updateable state, 
    3)	methods
    4)	message queue. 
 
Advantage of this mode is that it unifies imperative object-oriented programming and concurrent programming without suffering from omnipresent race conditions. 

AmbientTalk’s object model `avoids race conditions` using following rules: 
{1} `Containment`: Every passive object is contained within exactly one active object. 
{2} `Argument Passing Rules`:  When an asynchronous message is sent to an active object, objects may be sent along as arguments. 



(2) The Passive Object Layer:

(3) The Active Object Layer:

(4) First-class Mailboxes:

* This paper presents an example of AmbientTalk at Work: AmbientChat 

(1) Ambient References:

(2) Non-blocking Futures: 

(3) Due: Handling Failures: 

(4) Due-blocks:

* Conclusion and Future Work 

AmOP privides new direction of exploration for future filled with IoT market.  Since AmOP is still in evolution stage it is difficult to come up with good software-engineering criteria for future AmOP language features. This is the reason the paper presents AmOP paradigm as a set of characteristics for programming languages that directly deal with hardware phenomena in the very heart of basic computational abstractions. Reified communication traces may be useful in solving transaction management in classic distributed systems, as already exemplified by optimistic process collaboration approaches such as the Time Warp mechanism. More insight is required on how to map AmOP features on efficient implementation technology which results in need of new distributed memory management techniques. 

## Analysis

Comparisons:
Languages like ABCL/f and Argus promote a scheme based on futures [14] partially solve problems related to mobile network but their objects block when accessing unresolved futures.
Janus, Salsa and E are the languages based on Actor models which use pure asynchronous communication. However, there is no support to discover ambient resources or handling of volatile connections among autonomous computing units. 

It is impossible to prove that Classless Object Models, Non-Blocking Communication Primitives, Reified Communication Traces and Ambient Acquaintance Management
 are strictly necessary characteristics for writing the applications we target. After all, AmOP does not transcend Turing equivalence. 


## References





