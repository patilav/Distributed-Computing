
<meta charset=utf8>

# "Ambient-Oriented Programming in AmbientTalk", Dedecke, Cutsem, Mostinckx, D’Hondt, and De Meuter July 2006

Avanti Patil <patil.av@husky.neu.edu>

## Synopsis
This paper presents a new age field in distributed programming called Ambient intelligence (AmI). With emerging IoT business new problems which can’t be solved by conventional methods in programming. This paper talks about AmbientTalk – which is Ambient-Oriented Programming language (AmOP). Properties of mobile networks prominently include volatile connections and open network. Implementing languages based on Ambient-Oriented Programming paradigm help to deal with such problems. Research in this paper show that needs of mobile network are different from stationary n/w., AmbientTalk which is based on AmOP paradigm helps to solve these problems.  These concepts were implemented in an ambient peer-to-peer instant messaging app which was deployed on smart phones as part of this research.

## Summary

AmbientTalk features a classless double-layered object model. Ac- tors are visible in mobile networks and communicate with each other in a non- blocking way. Internally, they contain a graph of passive objects. Actors have four mailboxes which reify their communication traces and four mailboxes which are causally connected to the outside world to reflect the evolution of acquaintances in the ambient. These properties turn AmbientTalk into an AmOP language 

* Motivation for Ambient-Oriented Programming language(AmOP)

(1) Connection volatility, Ambient resources, Autonomy in hardware, Natural Concurrency – these are collectively described as hardware phenomena which is inherent to mobile networks. 

(2) Previous distributed languages based on actor model and futures only solve problems for mobile networks partially.

(3) Distributed Middlewares based on RPC, Data sharing, Publisher subscriber or Tuple based model do not fully solve problems of mobile networks like n/w volatility, ambient resources, autonomy and concurrency or well integrate with the object- oriented paradigm.

* Ambient-Oriented Programming 

(1)	Classless Object Models:  Even in the absence of wireless distribution, languages like Smalltalk and CLOS already illustrate that a serious reification of classes and their relation to objects results in extremely complex meta machinery. To avoid this complexity and proven classless object model of existing distributed programming languages such as Emerald, Obliq, dSelf and E moves AmOP to follow the same model. 

(2)	Non-Blocking Communication Primitives: 

This is a solution provided to avoid problems like autonomy. Non- blocking reception gives rise to event-driven applications, responsive to the stream of events generated by spontaneously interacting autonomous devices. Hence AmOP language needs a concurrency model without blocking communication primitives 

(3)	Reified Communication Traces:

Inconsistency is a huge issue in Non-blocking communication. AmOP paradigm has to provide programmers with an explicit representation (i.e. a reification) of the communication details which led to the inconsistent state. Reifying outgoing communication traces allow programmers to make a tradeoff between different delivery guarantees.

(4)	Ambient Acquaintance Management:

AmOp follows `Distributed naming`: where communicating parties do not need an explicit reference to each other beforehand. e.g. In Tuple space based middleware, a process can publish data in a tuple space, which can then be consulted by the other processes based on a pattern matching basis. AmOP language should allow an object to use distributed naming to spontaneously get acquainted with a previously unknown object based on an intentional description of that object rather than via a fixed URL. 

* The AmbientTalk Kernel 

AmbientTalk, is a language that was explicitly designed to satisfy its characteristics defined by Ambient-Oriented Programming. 

(1) A Double-layered Object Model:
AmbientTalk uses concurrent object model which is based on the model of ABCL/1.
This model features active objects which consist
    1)	perpetually running thread, 
    2)	updateable state, 
    3)	methods
    4)	message queue. 
 
Advantage of this mode is that it unifies imperative object-oriented programming and concurrent programming without suffering from omnipresent race conditions. 

AmbientTalk’s object model `avoids race conditions` using following rules: 
{1} `Containment`: Every passive object is contained within exactly one active object. 
{2} `Argument Passing Rules`:  When an asynchronous message is sent to an active object, objects may be sent along as arguments. 
AmbientTalk’s distribution model is a combination of actor model, imperative thread model and the prototype-based object model.

(2) The Passive Object Layer:

AmbientTalk passive objects are conceived as collections of slots mapping names to objects and/or methods. Slots can be mutable (:) or immutable (::).Objects are lexically scoped. Objects can also be created by extending existing ones. Messages not understood by the newly created object are automatically delegated to the parent 

(3) The Active Object Layer:

AmbientTalk actors have their own message queues and computational thread which processes incoming messages one by one by executing their corresponding method. Therefore, an actor is entirely single- threaded such that state changes using the classic assignment operator := cannot cause race conditions. Actors are created using the actor(o) form where o must be a passive object that specifies the behavior of the actor. In order to respect the containment principle, a copy of o is made before it is used by the actor form because o would otherwise be shared by the creating and the created actor. A newly created actor is immediately sent the `init()` message and this Actor denotes the current actor. In the case of synchronous messages of the form the arguments do not “leave” the actor and can therefore be safely passed by reference. 
In the case of asynchronous messages of the form the arguments “leave” the actor from which the message is sent. When passing along arguments with (both synchronous and asynchronous) message sends, caution is required in order not to breach the containment principle. 

(4) First-class Mailboxes:

Mailboxes are first-class passive objects contained in the actor. AmbientTalk replaces the single message queue of the original actor model by a system of eight first-class mailboxes.  Types of messages are distinguished: 
1.	outgoing messages sent by actor that have not been acknowledged as received by other party (outbox)
2.	outgoing messages that have been acknowledged to be received (sentbox)
3.	non-processed but received incoming messages (inbox)
4.	processed received messages (rcvbox)
AmbientTalk actors have four additional predefined mailboxes called joinedbox, disjoinedbox, requiredbox and providedbox. 

AbientTalk as a reflexive kernel:  AmbientTalk’s kernel can be reflectively extended which consists of the double-layered object model along with the system of eight built-in mailboxes. The built-in mailboxes and their observers can be regarded as part of AmbientTalk’s meta object protocol (MOP) since they partially reify the state of the interpreter in Message reception as well as message processing. 

* This paper presents an example of AmbientTalk at Work: AmbientChat 

`AmbientChat` is an instant messenger application that epitomizes all the difficulties of mobile network applications in which multiple parties dynamically join and disjoin and collaborate without presuming a centralized server. 

(1) Ambient References: can discover actors fitting that description and are resilient to the effects of volatile connections.

(2) Non-blocking Futures: AmbientTalk’s futures avoid this problem by adopting the technique that was recently proposed in E. It allows for a transparent forwarding of messages sent to a future to its resolution and features a when (aFuture, closure) construct to register a closure that is to be applied upon resolving the future. 

(3) Due: Handling Failures: AmbientTalk’s default delivery policy guarantees eventual delivery of messages. Messages are stored indefinitely in the outbox of an actor until they can be delivered. The due language construct alters this policy by putting an expiration deadline on outgoing messages.

(4) Due-blocks: are similar to try-catch blocks.

* Conclusion and Future Work 

AmOP privides new direction of exploration for future filled with IoT market.  Since AmOP is still in evolution stage it is difficult to come up with good software-engineering criteria for future AmOP language features. This is the reason the paper presents AmOP paradigm as a set of characteristics for programming languages that directly deal with hardware phenomena in the very heart of basic computational abstractions. Reified communication traces may be useful in solving transaction management in classic distributed systems, as already exemplified by optimistic process collaboration approaches such as the Time Warp mechanism. More insight is required on how to map AmOP features on efficient implementation technology which results in need of new distributed memory management techniques. 

Future work done in a chat application with similar goals – called BlueChat implemented in Java using Bluetooth counts no less than 545 lines of code and allows ambient acquaintance discovery.

## Analysis

Languages like ABCL/f and Argus promote a scheme based on futures partially solve problems related to mobile network but their objects block when accessing unresolved futures.
Janus, Salsa and E are the languages based on Actor models which use pure asynchronous communication. However, there is no support to discover ambient resources or handling of volatile connections among autonomous computing units. 

It is impossible to prove that Classless Object Models, Non-Blocking Communication Primitives, Reified Communication Traces and Ambient Acquaintance Management are strictly necessary characteristics for writing the applications we target. After all, AmOP does not transcend Turing equivalence. 

In conclusion 

(1) The implementation of ambient references heavily relies on AmbientTalk’s ambient acquaintance management facilities

(2) AmbientTalk’s non-blocking futures delay the delivery of received messages until the expected result is ready to receive them. It reflects that reified communication traces are at the heart of realigning synchronization with communication while strictly relying on non-blocking communication primitives

(3) The due language construct shows that although AmbientTalk’s default message delivery policy implements a resumable communication model, it can still cope with permanent failures by reflecting upon an actor’s communication traces.

Finally, it is impossible to prove that AmbientTalk’s building blocks are necessary and sufficient to cover all future AmOP features.

Parting thoughts include:
Paper describes that efficiency was not it’s primary concern in conceiving the implementation of AmbientTalk. Given the strategy of managing overhead of queues it is reasonable to come to this conclusion. 

