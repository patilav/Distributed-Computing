                                               # Erlang
                                               
Issues arise in multi core computers due to the shared memory model. The consistency becomes a challenge when multiple processes access the same memory and further, the workarounds to tackle the same turn into a hassle. This paper introduces us to an age old concurrent programming language - Erlang and the way it harmonizes with the modern multi core computers by moving away from the shared memory model and adopting a message passing model. Author emphasizes specially on Erlang’s unique feature - component isolation and how it helps solve the major challenges in a distributed system like fault tolerance, maintainability and scalability.

The message passing model is heavily dependent on the network. Author states an assumption in the paper that the network is always reliable. 

Erlang manages its own light weight processes and adopts asynchronous message passing model between them for communication of data. Component isolation is achieved by ensuring no access to local data of a process from outside itself. Two processes on distant cores can communicate by writing to/receiving from a shared channel.  Erlang extends this model (no semantic changes added) to cater to processes residing in separate nodes in a distributed system. Scalability is as easy as adding another node (with Erlang process running) to the cluster without any changes to the existing system.
In an Erlang based distributed system, It is ok for the processes to crash. Erlang provides a mechanism “link” which enables signaling of crash of process X to its linked monitor process Y. The process B can then determine the cause and bring the process X to life. These error monitoring processes are dedicated processes which monitor for any failures in the distributed system. They form another layer completely different from application logic layer. The data structures are dynamically typed making it impossible to create corrupt data. Erlang is highly fault tolerant. 
The message passing model involves receive for receiving messages from the sender and “!”  (send) against the senders process id to send messages. The syntax receive is non blocking and performs pattern matching on the received message to identify the message format (ones with senders PID) and execute actions accordingly. Send and receive are highly important for building own interprocess communications.
The link(PID) helps monitoring processes to trap the exit signals of the processes and execute upon the reason of their failure. One can build their own on_exit(Pid, F) function to build a hierarchical tree of processes where in a parent node can monitor its children processes for failure.
Erlang provides try-catch-end to catch any exceptions resulting out from an execution of a transaction. In case of a failure, the process can notify the sender and it can continue to execute in a tail recursion fashion. The tail recursion in Erlang moves only forward and won’t go back like in a regular recursion. The previous state need not be saved on the stack and can be safely garbage collected.
A process can be easily upgraded by adding a new pattern to the receive syntax to automatically detect the new code and transform to it.
The paper discusses about OTP, the highly powerful set of libraries which help developers to follow the right design patterns while building dynamic up gradation of code and error handling mechanisms. 
The author concludes by substantiating his conceptions by stating several successful real world implementations using Erlang. AXD301 switch was effectively designed in Erlang and employs a pure message passing model. It has proven to be highly scalable and modular.
Instant Messaging often involves communications between several open channels. Erlang’s projects MochiWeb (powers Facebook messenger app), Ejabberd, RabbitMQ provides high throughput, low latency and asynchronous message passing enables handling the challenges in Instant messaging. CouchDB, Amazon SimpleDB and scalaris are schema free databases which leverage Erlang’s own database “mnesia” to store any complex data structure like JSON, XML trees in database and execute queries against them. 

The paper has made several assumptions with regards to communication and security. Since the distributed system depends on message passing, how does it scale with increasing data? What is the protocol used for communication between processes? Is the protocol safe? How does Erlang work in heterogenous environment?

The author has done a very good job in explaining the goal and achievements. The author has expressed his thoughts in a well organized manner starting from the birth of the language to the motivation behind the unique features and how it solves the real world problems to the implementation of several successful projects using Erlang.
