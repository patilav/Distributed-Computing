This paper presents the initial design of the Remote Procedure Calls (RPC), their client and server-side implementations, the security, and the communication protocol used between the clients and the server including the initial setup.
This paper discusses implementing RPCs in the Cedar programming language allowing for an easier and secure distributed computation with semantics that are similar to that of a local procedure call. They defined the main components of the RPCs; the user and server sections, their respective stubs, and the a communication protocol called RPCRuntime. The user and server sections are written by the programmer, while the stubs are auto generated by a program called Lupine, allowing for a minimum overhead for the programmer. The server side program is registered and bound to a name(type and instance) in a distributed  Grapevine database. Clients connect to this database to access different server programs, and this database is responsible for access control and establishing an initial secure communication. The authors also describe a detailed implementation and design choices for the RPCRuntime. Unique identifiers are used by the clients and server to identify themselves. The result of the RPC either returns on result or an exception(if anything goes wrong).
The RPC model is a synchronous blocking model, which might be an ideal choice for consistency, however, it might not be the best choice for availability. It also limits the amount of information that can be transferred from the client to the server(using only arguments to the function).  Moreover, the communication method(sending duplicates and sequence numbers) described by the authors might be considered efficient when this paper was published, however, it can be made more efficient today. Moreover, if RPC systems can access databases(accessible by both the client and the server), they could use these to transfer larger files between them.  
This paper is old, however, RPC concept is still used today.  Some of their choices are relatively slow(like their communication scheme). However, this paper presents a way to outsource a large computation to a different machine, with minimal effort and having the same interface available to the client. It lays the foundations of many of the later programming paradigms (like MapReduce).
 
